# 소프트웨어가 지켜야 할 가치

> DTO, VO, DAO로 분류하는데 집중하지 말고, 이 객체들이 왜 생겨났는지에 집중하라.
> 객체들을 분류하려고 하지 말고, 가치들을 지키려고 노력하자.

- 불변성: 변하지 않는가
- 예측 가능성: 항상 같은 결과를 반환하는가
- 자가 검증: 유효한 값인가

### 불확실성

소프트웨어는 불확실성으로 가득한 복잡계.

- 네트워크 호출은 불확실하다
- 참조하는 객체가 변수가 있다면 그 값은 불확실하다.

그래서 믿을 수 있고 확실한 영역을 최대한 많이 만들어내는 것이 중요하다.
= 항상 변하지 않고 똑같은 결과와 똑같은 값만 돌려주는 코드

소프트웨어에서 모든 불확실성을 없애는 것은 불가능.
개발 자체가 불확실성을 전제로 이루어지며, 대부분의 소프트웨어는 상태 변화에 따라 다르게 동작하도록 만들어짐.

그러니 최대한 줄이는 방향으로 가야한다.

### 예측 가능성

> 우리는 자동차의 엑셀을 밟을 때 차가 가속되길 기대한다. 그리고 브레이크를 밟을 때 차가 멈추길 기대한다.
설사 100억 분의 1이더라도 이를 벗어나서는 안된다.

우리는 엑셀, 브레이크 기능이 제대로 만들었다고 신뢰한다.

하지만 진짜인가? 정말 이 기능이 엑셀을 밟을 때 가속될까? 

엑셀이란 기능이 정말로 제기능을 하는지 신뢰 뿐만 아니라 **'예측 가능할'** 수 있어야 한다.

OOP는 확장성, 유지보수성을 늘릴 수 있다. 하지만 이러한 예측 가능성은 OOP 이론으로는 보장받을 수 없다.

우리는 순수함수를 만들어야 한다.

> 현대의 과학이 비결정적이고 예측불가능한 토대 위에 세워져 있다면 어떻게 될까? 우리는 중세시대로 돌아가게 될 것이다.

### 불변성

#### 값을 불변하게 만들자.

`final`로 보장하는 불변성.

- `Collection`이나 우리가 만든 타입을 가진 필드 값은, `final`로 선언해도 그 안에 값이 `final`이 아니라면, 수정할 수 있다.
- 순수 함수를 만들기 위해 class에도 `final`로 선언해야 한다. 상속된 클래스의 필드가 불변이 아닐 수 있기 때문이다.

#### 예측 가능한 방식으로 만들자.

**순수 함수를 만들어보자. 상태 값을 업데이트 할 때 새로운 객체를 만들어, 서로 공유할 수 없게 만들었다.**

멀티 쓰레드 환경에서, 같은 domain 객체를 두고 서로 업데이트 하려고 한다면 어떻게 될까?

트랜잭션에서 발생할 수 있는 문제와 동일하게 발생할 것이다.

```java
public AccountInfo setMileage(long mileage) {
    return this.mileage = mileage;
}
```

이 상황을, 필드 값을 불변으로 만들고, 새로운 VO를 만들어 반환하게 한다면?
기존 필드값은 그대로 유지되므로 각각 값을 반환할 수 있다.

```java
public AccountInfo setMileage(long mileage) {
    return new AccountInfo(this.id, mileage);
}
```

물론, Servlet을 사용하는 일반적인 웹 어플리케이션이며, 스케쥴링 및 이벤트 기반의 설계가 없다면 이런 일이 발생할 확률은 드물다고 생각한다.

하지만 소프트웨어를 만드는 개발자 입장에서 이런 고민 자체를 없애주는 것이 현명한 선택일 것이다.

이를 통해 프로그램이 **예측 가능한 형태로 바뀌었다!** -> 같은 객체에 같은 메서드를 호출하면 항상 같은 결과를 받을 수 있다!

(48p, 49p 그림 참고)

❗ 동등성과는 다른 개념입니다!

### 동등성

```java
Color green1 = new Color(0, 1, 0);
Color green2 = new Color(0, 1, 0);
// green1 == green2 ??
```

`equals`와 `hashCode`메서드가 없는 `Color` 객체라 했을 때, `green1`과 `green2`는 같은 객체라고 판단할까?

자바는 기본적으로 hashCode를 기준으로 판단하기 때문에, `green1`과 `green2`는 다르다고 판단할 것이다. 같은 rgb인데도 말이다.

> 어떤 객체가 값이고 상태가 모두 같다면 같은 객체로 봐야 한다.

우리는 불확실성을 제거하는게 개발자에게 도움이 된다는 사실을 알고 있다. 제거해보자!

간단하다. `equals`와 `hashCode`를 오버라이딩하여 상태를 비교하는 코드로 바꾸자.

> 상태가 같다면 객체 비교 시 무조건 같은 값임을 보장하게 만들어 불확실성을 제거했다.

#### lombok의 `@Value`

동등성을 `equals`와 `hashCode`를 통해 보장하게 만들고 싶다면, lombok에서 이를 자동으로 만들어주는 어노테이션이 존재한다.

### 식별자와 VO

```java
AccountInfo account1 = new AccountInfo(1, 20_000);
AccountInfo account2 = new account1.withMileage(70_000);
// account1 == account2 ??
```

`AccountInfo`에 식별자 `id`값이 존재한다고 했을 때, 이는 같은 

#### 더 생각해봐야 할 점

🤔 DB는 id 값으로(PK) 동등성을 비교할 수 있고, 트랜잭션 격리 수준을 이용하여 어느정도 동시성 문제를 해결할 수 있다. 그럼 어플리케이션 단에서의 domain에 대한 동등성 및 동시 수준은 어떻게 해결할 수 있을까? 이런 문제는 처음 생각해보기 때문에 많은 학습이 필요하다.

[Jpa Entity 의 Equals, 객체 동일성과 동등성, Lombok 을 써도 될까? - SeungKwon Park](https://blog.yevgnenll.me/posts/jpa-entity-eqauls-and-hashcode-equality)

🤔 불변성과 동일성은 같은 의미라고 생각했지만, 아예 다른 의미였다. 하지만 순수 함수는 이 둘에게 모두 적용되는 듯 했다. 이에 대해 더 공부해보자.




# 역할과 책임의 차이

interface, 그 안에 구체적 책임
