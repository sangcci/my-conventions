# 기존 권한 처리 방법 문제점

기존에는 다음과 같이 권한 처리 로직을 구현한 후에 일일이 service 로직에서 분기를 통해 활용했다.

하지만 다음과 같은 문제점이 존재했다.
- User에 대한 추가적인 Role 체크
- 로직 중복

```
ScheduleAdminController
ScheduleController

ScheduleCommandService
ScheduleQueryService
```
Controller 단에는 각 접근 권한 별로 엔드포인트를 구분하였다. Service는 트랜잭션의 구분 및 CRUD 책임 분리를 위해 저수준 CQRS로 구현하였다.

이렇게 되면 Service 단에서도 **CRUD를 권한 별로 메서드로 구분해서 작성해야 하는 문제점**이 발생한다.

그래서 if문을 활용하여 `User`의 `Role`를 체크하며 권한 체크를 분기할 수 있도록 구현했다.

Service에서 권한 체크 구문에서 중복이 발생했고, 이를 아무리 메서드로 묶어서 관리한다고 해도 
```java
groupAuthService.validateCourse(courseId, username);
```
한 줄의 중복이 발생했다.

### Controller에서 처리

아예 권한 검증 로직을 `GroupAuthService`로 묶어서 각 controller에서 처리하도록 구현했다.

하지만 여전히 똑같이 중복이 발생했다.

```java
@GetMapping("/{id}")
    public ResponseEntity<Response<ScheduleResponse>> getSchedule(
            @RequestParam String accessType,
            @PathVariable("id") Long scheduleId
    ) {
        if (accessType.equals("TEAM")) {
            return ResponseEntity.ok(
                    Response.success(teamScheduleQueryService.getTeamSchedule(scheduleId)));
        }
        else if (accessType.equals("COMMON")) {
            return ResponseEntity.ok(
                    Response.success(courseScheduleQueryService.getCourseSchedule(scheduleId)));
        }
        else {
            throw new AppException(ACCESS_TYPE_NOT_ALLOWED);
        }
    }
```

### 

# 결과

책임 분리와 더불어 코드의 중복 제거까지 이룰 수 있었다.
Controller 단, 즉 web 단에서는 이렇게 권한 검증 로직까지 도맡아서 분리하여 구현하는 것이 좋다고 생각한다.

---

[스프링 인터셉터와 어노테이션으로 인증 및 권한 관리하기](https://willseungh0.tistory.com/84)

