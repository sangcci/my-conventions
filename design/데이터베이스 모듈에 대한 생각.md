# ddd와 er 그 사이 어딘가

프로젝트 진행하면서 항상 느꼈던 건, 연관관계가 많이 얽혀 있다면, 테스트 작성할 때 delete할 수 없어서 따로 작업이 필요하다..

제일 중요한 점은, 과연 내가 도메인 주도 개발을 하는가에 대한 의문이다.
기능을 먼저 생각하고 작성하지만, 막상 개발을 진행하면 결국 erd와 같도록 귀결된다.

프로젝트 진행할 때 ERD 설계가 한 차례 크게 바뀐 적이 있었다.

해당 프로젝트에서는 레이어드 아키텍처를 사용하고 있었는데, database entity와 domain entity를 구분하지 않고 있었고,
이에 ERD의 테이블 구조와 종속되어 같이 바뀔 수 밖에 없었다.

서비스 코드에서도 repository를 가지고 있었고, repository 자체를 변경하는 작업을 요하게 되었다.

여기서 중요한 깨달음은,
> 객체의 행동, 즉 프로젝트의 요구사항들을 기능별로 분리하고 이를 구현하는 절차가 아닌, 데이터를 먼저 생각하고 이를 기능으로 치환하는 작업을 거치고 있었다는 점이다.

내 딴에는 ddd를 설계한다고 생각했는데 결국 단순히 비즈니스 로직만을 분류하는 작업을 하고 있었고, ddd 설계의 본질인 객체지향을 지키지 않았다.

# Database는 추상화를 할 수 없다.

다른 패러다임이 가지지 못하는 객체 설계가 가지는 가장 큰 장점이라고 생각한다.

추상화를 통해 느슨한 결합을 설계할 수 있으며, 이를 통해 의존성을 역전시켜 분리하는 작업을 거쳐 영향권을 없앤다.

이로써 유지보수성과 확장성을 동시에 가져갈 수 있다.

추상화를 하는 방법은 정말 많으며, 이에 대한 방법은 오브젝트 책에 자세히 나와있다.

# 모듈 분리

데이터베이스의 데이터 구조와 종속되는 문제를 해결하기 위한 방안으로, 핵사고날 아키텍처에서 등장한 개념이다.

현재 나의 Entity는 다음과 같은 책임을 가진다.
- 비즈니스 로직
- 데이터 검증
- 데이터 상태 저장

이 중에서 데이터 상태를 저장하는 책임을 같이 가지고 있다 보니, 자연스레 데이터베이스와 종속되는 구조를 가질 수 밖에 없었다.

그래서 이를 
- `port - adapter`로 구분하고
- domain entity와 database entity를 구분
하면 어떨까라는 생각을 했다.

장점으로는,
domain과 infra 모듈로 분리되어 domain <- repository의 의존성 방향이 설정되어 domain은 순수하게 유지할 수 있다.

domain 로직이야 말로 객체지향에서 제공하는 추상화의 이점 때문에 확장성, 유지보수성을 챙기기 좋다.

그래서 어플리케이션 설계할 때 domain을 제일 중점으로 두고 설계하며, infra는 데이터 상태를 저장하고 가져오는 용도로만 사용하도록 구현한다.

단점으로는,
오버 엔지니어링이 될 수 있다.

유지보수가 그렇게 필요로 하지 않는 간단한 로직인 경우 오히려 비즈니스 로직보다 entity를 분리하는 작업에서 시간을 더 뺏길 수도 있다.

기능이 어느정도 추가가 되었을 때 시간을 잡고 리팩토링 작업을 진행하는 것이 좋아 보였다.
