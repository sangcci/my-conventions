- 테스트 하고자 하는 의도가 무엇인지 정의해야 한다.

  정답은 없다. 내가 생각한 대로 테스트를 진행하면 된다. 그러면 테스트 코드가 알려줄 것이다. 내가 짜놓은 이 코드(의도)가 제대로 된 설계인지.

- Mockito는 Stub을 편하게 할 수 있는 프레임워크 그 이상 그 이하도 아니다.

  무조건 Mockito를 사용해야 한다는 생각은 버리자. 내가 무엇을 검증하고 싶은지, 해당 Layer에서 어떤 책임을 할당했고, 다른 외부 로직은 다른 모듈에게 메세지를 보내 책임을 전가할 것인지,
  그 책임은 우리가 테스트 하지 않아도 되기 때문에 stub으로 감싸는지.

  일단 마음대로 정해보자. 뭔가 제대로 테스트 코드를 짜기 힘든 경우가 있다. 몇 번씩 코드를 타고 가야되는 로직이 많이 존재한다면, 이는 책임을 분리하라는 신호!

# 품질 보증, 품질 개선

우리가 의도하고자 하는 바를 테스트 코드에 그대로 녹여, 다른 개발자들이 이를 보고 동작 방식을 이해할 수 있을 것이다.

하지만 품질을 개선시키는 작업도 이뤄질 수 있다. '테스트가 보내는 신호'가 품질 개선에 포함된다.

> 테스트를 어떻게 하면 쉽게 작성할 수 있을지 고민

### Tastablitity

테스트 가능성

테스하기 쉬운 코드 -> Testablitiy가 높음 -> 좋은 설계

### 테스트를 어렵게 하는 요소

테스트 하기 쉬운 코드와 어려운 코드를 어떻게 분류할 수 있을까?

'테스트하려는 대상의 입력과 출력'에 있다.

- 테스트하려는 대상의 입력을 쉽게 변경할 수 있고, 출력을 쉽게 검증할 수 있을 때 작성하기 쉽다.
- 테스트하려는 대상에 숨겨진 입력이 존재하거나 숨겨진 출력이 있을 때 테스트 검증하기 어렵다.

> 어떻게 강제로 테스트 하게 할 수 있을까? 보다는 왜 이런 일이 발생했을까를 생각하자. 근본을 생각하자.

시간에 쫓겨 어떻게든 Mockito를 활용해서 stub 혹은 mocking하려는 시도가 많았을 것이다. 

다시 생각해보면, 테스트는 계속 우리에게 신호를 보내고 있었다. 책임을 분리하라는 신호. 즉, 숨겨진 요소가 많았던 셈


어떤 사례가 있는지를 비교해보자.

# 코드 사용자 입장

테스트의 신호를 포착할 수 있는 이유는 '코드 작성자' 입장에서 코드를 바라보는 것이 아니라 '코드 사용자' 입장에서 바라볼 수 있게 되기 때문입니다.

> 테스트를 위해 구현 코드를 변경하라. 구현 코드를 변경하지 않으면서 테스트를 강제로 할 수 ㅇ있는 강력한 해결책을 찾아다닌다. 예를 들어 Mockito 등..
