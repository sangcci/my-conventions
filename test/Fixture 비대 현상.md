# Fixture 사용 이유
테스트를 하기 위해 테스트에 필요한 데이터 객체들이 필요하다.

데이터 객체에 필드들이 많아질수록 생성하는데 필요한 데이터도 많아진다는 의미이고,
이는 자연스럽게 생성자 크기의 비대로 이어졌다. 
테스트 코드에서 코드의 비대는 곧 가독성과도 연결되고, 테스트 코드를 잘 이해하지 못하는 경우가 발생한다.

그래서 이러한 현상을 방지하기 위해 `Fixture`를 도입했다.

# Fixture 비대 현상

### 연관 관계
JPA를 사용하면 자연스럽게 해당 객체 타입 자체를 필드로 가지는 경우가 많다. 특히 연관관계가 많아질수록, 연관되는 객체들도 자연스레 많아진다.

이는 Fixture를 만들 때 불편하게 작용했다.

`Schedule`을 만들기 위해 `Team`을 생성해야 했고, `Team`을 생성하기 위해 `User`와 `Course`를 생성해야 했다.

### DTO

데이터를 받기 위해 각 CUD마다 `Command`, `Response`가 만들어지는 경우가 많다.

이들은 주로 데이터를 외부에서 받아서 파싱하고, 간단한 검증 과정을 거쳐서 Service에게 넘겨주는 단순한 역할을 담당하지만,

당시 내가 했던 프로젝트에서는 `CreateCommand`에게 비즈니스 로직과 관련있는 데이터 검증 책임,
`Domain`으로 변환하는 로직까지 담당하고 있었다.

그래서 이들도 도메인 비즈니스 로직과 관련 있다고 생각했고, 이를 domain 단위 테스트에 작성했었다.

### 다양한 예외 상황

비즈니스 로직에서는 정말 다양한 상황이 발생하고 이들을 모두 테스트 해봐야 한다.

다양한 상황이 발생한다는 것은 결국 데이터 객체에 각자 다른 값들이 들어있어야 하는 상황이었고, 자연스레 이를 생성하는 메서드가 많아졌다.

### 결과

`Fixture`의 크기가 비대해졌다!

이를 어떻게 해결할 수 있을까

# 해결 과정

