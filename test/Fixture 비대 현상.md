# Fixture 사용 이유
테스트를 하기 위해 테스트에 필요한 데이터 객체들이 필요하다.

데이터 객체에 필드들이 많아질수록 생성하는데 필요한 데이터도 많아진다는 의미이고,
이는 자연스럽게 생성자 크기의 비대로 이어졌다. 
테스트 코드에서 코드의 비대는 곧 가독성과도 연결되고, 테스트 코드를 잘 이해하지 못하는 경우가 발생한다.

그래서 이러한 현상을 방지하기 위해 `Fixture`를 도입했다.

# Fixture 비대 현상

### 연관 관계
JPA를 사용하면 자연스럽게 해당 객체 타입 자체를 필드로 가지는 경우가 많다. 특히 연관관계가 많아질수록, 연관되는 객체들도 자연스레 많아진다.

이는 Fixture를 만들 때 불편하게 작용했다.

`Schedule`을 만들기 위해 `Team`을 생성해야 했고, `Team`을 생성하기 위해 `User`와 `Course`를 생성해야 했다.

-> 이 문제는 따로 포스팅 예정

### DTO

데이터를 받기 위해 각 CUD마다 `Command`, `Response`가 만들어지는 경우가 많다.

이들은 주로 데이터를 외부에서 받아서 파싱하고, 간단한 검증 과정을 거쳐서 Service에게 넘겨주는 단순한 역할을 담당하지만,

당시 내가 했던 프로젝트에서는 `CreateCommand`에게 비즈니스 로직과 관련있는 데이터 검증 책임,
`Domain`으로 변환하는 로직까지 담당하고 있었다.

그래서 이들도 도메인 비즈니스 로직과 관련 있다고 생각했고, 이를 domain 단위 테스트에 작성했었다.

### 다양한 Fixture

비즈니스 로직에서는 정말 다양한 상황이 발생하고 이들을 모두 테스트 해봐야 한다.

다양한 상황이 발생한다는 것은 결국 **데이터 객체에 각자 다른 값들이 들어있어야 했고**, 자연스레 이를 생성하는 메서드가 많아졌다.

### 결과

`Fixture`의 크기가 비대해졌다!

이를 어떻게 해결할 수 있을까

# 분석

### Fixture 사용 자체가 옳은지

향로 님의 블로그에서 테스트 Fixture에 대한 의견을 참고했다.

> 테스트 메서드는 그 자체로 완전한 프로그램이어야 한다.

프로젝트에서 Fixture 내부에 어떤 데이터가 들어있는지 모르는 경우 `Fixture` 클래스로 넘어가서 확인하는 경우가 있었다.

이렇게 하나의 테스트를 이해하기 위해 일명 '클래스 타고타고'를 반복하기 때문에 다른 사람들이 읽기에 불편할 것 같다고 생각했다.

### 

# 해결 과정

### setUp

공통된 Fixture들은 beforeEach로 생성하고 테스트 메서드에서 공유하는 방식이다.

하지만 이 경우, 요구 사항이 변경되어 공통 Fixture를 건드려야 할 상황이 생길 시 타 메서드까지 영향을 미칠 수 있다.

김우근님의 의견에 따르면

> 기본적으로는 보수적으로 접근하는 편이고, 각 테스트에서 전혀 몰라도 되는 준비 과정만 setUp() 과정으로 분리하려고 하는 편

즉, 우리가 테스트하는 로직들 중에서 "이건 절대로 바뀌지 않을 것 같다"는 것만 따로 빼서 공통으로 묶어놓는다.

### Fixture 분리

간단한 방식이다! Fixture 안에는 domain을 제외하고도 `CreateCommand`, `UpdateCommand` 등 DTO까지 생성하는 로직이 함께 포함되어 있었다.

이를 class 단위로 분리하니, 확실히 관리하기 편해졌다.

하지만 domain 안에서의 Fixture 분리는 이루어지지 않았다.

### Enum 도입

원래는 
- `createSchedule_ATTEND`
- `createSchedule_SCRUM`
등 데이터 종류를 구분하기 위해 메서드의 접미사에 추가했다.

하지만 테스트 코드에 적용해보니 가독성의 이점을 얻지 못했고, 오히려 더 지저분해지는 결과를 가져왔다.

Enum을 도입하면 어떻게 될까?

-> 그렇게 가독성이 좋아진다는 느낌은 받지 못했고, static class로 만드는 것과 비슷하다고 생각했다.

### 테스트 범위를 한정하자

오랫동안 고민한 결과 다음과 같은 결과를 얻었다.
> 테스트할 필드 값만 테스트하라.

다음과 같은 비즈니스 검증 로직이 존재한다고 해보자.
- 출결 시간은 9시에서 18시 사이에서만 설정할 수 있다.

해당 검증에 대한 테스트는 `startAt`과 `endAt`만 관여한다. 다른 필드는 관여할 필요가 없다.
출결 타입별로 `LATE`, ` ABSENT`, `EARLY`, `OUTING` 4가지 경우에 대해 모두 검증할 필요가 없다는 의미다(시간 제약이 없는 타입이 추가된다면 해당 타입에 대한 테스트만 열외하면 된다, 이 테스트는 따로 작성하는 것이 좋다고 생각).

이처럼 테스트 할 필드 값만 관여하면 되기 때문에,
**Builder pattern**을 사용해서 필요한 필드 값만 생성하고 나머지는 자동 `null`처리 하게끔 구현하는 전략을 선택했다.

> 고정된 것은 유지하고 변화가 있는 것만 확장하라.



---

[테스트 픽스처 올바르게 사용하기 - 향로](https://jojoldu.tistory.com/611)

[이 경우, @BeforeEach에 fixture를 구성해도 될까요? - 실용적인 테스트 가이드 강의 Q&A 김우근](https://www.inflearn.com/community/questions/947467/%EC%9D%B4-%EA%B2%BD%EC%9A%B0-beforeeach%EC%97%90-fixture%EB%A5%BC-%EA%B5%AC%EC%84%B1%ED%95%B4%EB%8F%84-%EB%90%A0%EA%B9%8C%EC%9A%94)
