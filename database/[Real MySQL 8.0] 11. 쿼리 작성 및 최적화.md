# 11.1 쿼리 작성과 연관된 시스템 변수

### 11.1.2 영문 대소문자 구분
설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.

- 윈도우: 대소문자 구분 X
- 유닉스: 대소문자 구분 O

> 애초에 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.

### 11.1.3 MySQL 예약어
예약어로 테이블을 생성하지 말자.

직접 MySQL에서 테이블을 생성해 보고 에러가 나는지 확인해보자.

# 11.3 MySQL 연산자와 내장 함수
MySQL에서만 사용하는 연산자가 많이 존재.

> 가능하면 ANSI 표준 형태의 연산자를 사용하길 권장한다.

💡`sql_mode`값에 "ANSI" 설정하면 SQL 표준 표기법만 사용할 수 있게 강제할 수 있다.

### 11.3.1 리터럴 표기법 문자열

#### 문자열
표준은 홑따옴표(')를 사용하여 표시. MySQL에서는 쌍따옴표(")도 가능.

홑따옴표를 지키도록 노력하자.

#### 숫자
표준은 따옴표 없이 숫자를 그대로 기입.

```sql
SELECT * FROM OO WHERE number_column='1000';
SELECT * FROM OO WHERE string_column=1000;
```
숫자 타입을 문자와 비교하는 경우, '1000'만 바꾸면 되므로 성능 문제 X.

문자 타입을 숫자와 비교하는 경우, 문자 타입인 string_column을 전부 숫자로 바꿔야 한다. 인덱스 이용을 못할 수 있는 최악의 상황 발생

> 숫자 값은 숫자 타입의 컬럼에만 저장하도록 하자.

#### 날짜
표준은 날짜 타입을 `DATE` 타입으로 변환하는 코드가 필요.

하지만 MySQL는 MySQL 서버가 자동으로 변환.

#### 불리언
⚠️`BOOL`, `BOOLEAN` 타입이 존재하지만 내부적으로 `TINYINT`로 저장한다.

- TRUE -> 1
- FALSE -> 0

로 저장된다.

⚠️ 2, 3 등을 INSERT할 수 없기 때문에, 차라리 `ENUM`이나 `VARCHAR`로 명확하게 저장하는 것이 버그를 유발시키지 않음.

### 11.3.2 MySQL 연산자

#### 동등 비교
- `=`
- `<=>`: `=` + NULL값 비교

`<=>`은 NULL-Safe 하다.

#### 부정 비교
- `!=`
- `<>`

💡동등 비교와 통일해서 사용하도록 하자.

#### NOT 연산자
- `NOT`
- `!`

⚠️ 숫자, 문자에서도 사용할 수 있기 때문에, 부정의 결과값을 정확히 예측할 수 없는 경우에는 사용 자제

#### AND, OR 연산자
- `AND`
- `&&`

- `OR`
- `||`

`AND`나 `OR` 사용하도록 하자.

⚠️AND 연산자가 먼저 처리된다.

#### 나누기, 나머지 연산자
- `/`
- `DIV`

- `%`
- `MOD`

#### REGEXP 연산자

- `REGEXP`
- `RLIKE`

둘 다 Regular expression(정규 표현식)의 약자이다. 우리가 아는 정규 표현식을 따른다.

⚠️ `LIKE`와 전혀 다르다.

⚠️ REGEXP를 조건식에서 비교할 경우 인덱스 레인지 스캔을 사용할 수 없다.

#### LIKE 연산자

`%`와 `_`만 사용하여 문자열이 있는지 없는지 판단.

⚠️ "Christ%"와 같이 앞쪽에 문자 상수가 존재하면 인덱스 레인지 스캔을 이용할 수 있지만, "%rist"와 같이 와일드카드가 뒤 쪽에 존재한다면 
인덱스의 Left-most 특성으로 인해 레인지 스캔을 사용하지 못하고 인덱스 풀 스캔 방식으로 처리한다.

#### BETWEEN 연산자

⚠️ BETWEEN와 IN의 차이점

![image](https://github.com/user-attachments/assets/a6a0d3ac-fcfd-49df-a3eb-09d0700ea0f1)

둘 다 인덱스 레인지 스캔을 수행하지만, BETWEEN은 선형으로 검색하고, IN은 동등 비교를 하며 수행하기 때문에 d003 중에서 10005번 아래에 있는 값은 10005번 보다 높다는 것을
이미 알고 있다.

그래서 BETWEEN이 너무 많이 조회할 경우, IN으로 최적화 하는 방식을 고려해보자.

#### IN 연산자

앞서 BETWEEN에서 언급한 대로, 범위로 검색하는 것이 아닌 여러 번의 동등 비교로 실행한다.

8.0 버전 부터는 IN 절에 튜플(레코드)를 사용하면 풀 테이블 스캔이 발생하지 않고 인덱스 레인지 스캔으로 실행된다.

⚠️ NOT IN의 경우에는 부정형 비교라서 인덱스 풀 스캔이 발생한다.


