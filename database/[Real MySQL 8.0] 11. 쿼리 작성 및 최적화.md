# 11.1 쿼리 작성과 연관된 시스템 변수

### 11.1.2 영문 대소문자 구분
설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.

- 윈도우: 대소문자 구분 X
- 유닉스: 대소문자 구분 O

> 애초에 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.

### 11.1.3 MySQL 예약어
예약어로 테이블을 생성하지 말자.

직접 MySQL에서 테이블을 생성해 보고 에러가 나는지 확인해보자.

# 11.3 MySQL 연산자와 내장 함수
MySQL에서만 사용하는 연산자가 많이 존재.

> 가능하면 ANSI 표준 형태의 연산자를 사용하길 권장한다.

💡`sql_mode`값에 "ANSI" 설정하면 SQL 표준 표기법만 사용할 수 있게 강제할 수 있다.

### 11.3.1 리터럴 표기법 문자열

#### 문자열
표준은 홑따옴표(')를 사용하여 표시. MySQL에서는 쌍따옴표(")도 가능.

홑따옴표를 지키도록 노력하자.

#### 숫자
표준은 따옴표 없이 숫자를 그대로 기입.

```sql
SELECT * FROM OO WHERE number_column='1000';
SELECT * FROM OO WHERE string_column=1000;
```
숫자 타입을 문자와 비교하는 경우, '1000'만 바꾸면 되므로 성능 문제 X.

문자 타입을 숫자와 비교하는 경우, 문자 타입인 string_column을 전부 숫자로 바꿔야 한다. 인덱스 이용을 못할 수 있는 최악의 상황 발생

> 숫자 값은 숫자 타입의 컬럼에만 저장하도록 하자.

#### 날짜
표준은 날짜 타입을 `DATE` 타입으로 변환하는 코드가 필요.

하지만 MySQL는 MySQL 서버가 자동으로 변환.

#### 불리언
⚠️`BOOL`, `BOOLEAN` 타입이 존재하지만 내부적으로 `TINYINT`로 저장한다.

- TRUE -> 1
- FALSE -> 0

로 저장된다.

⚠️ 2, 3 등을 INSERT할 수 없기 때문에, 차라리 `ENUM`이나 `VARCHAR`로 명확하게 저장하는 것이 버그를 유발시키지 않음.

### 11.3.2 MySQL 연산자

#### 동등 비교
- `=`
- `<=>`: `=` + NULL값 비교

`<=>`은 NULL-Safe 하다.

#### 부정 비교
- `!=`
- `<>`

💡동등 비교와 통일해서 사용하도록 하자.

#### NOT 연산자
- `NOT`
- `!`

⚠️ 숫자, 문자에서도 사용할 수 있기 때문에, 부정의 결과값을 정확히 예측할 수 없는 경우에는 사용 자제

#### AND, OR 연산자
- `AND`
- `&&`

- `OR`
- `||`

`AND`나 `OR` 사용하도록 하자.

⚠️AND 연산자가 먼저 처리된다.

#### 나누기, 나머지 연산자
- `/`
- `DIV`

- `%`
- `MOD`

#### REGEXP 연산자

- `REGEXP`
- `RLIKE`

둘 다 Regular expression(정규 표현식)의 약자이다. 우리가 아는 정규 표현식을 따른다.

⚠️ `LIKE`와 전혀 다르다.

⚠️ REGEXP를 조건식에서 비교할 경우 인덱스 레인지 스캔을 사용할 수 없다.

#### LIKE 연산자

`%`와 `_`만 사용하여 문자열이 있는지 없는지 판단.

⚠️ "Christ%"와 같이 앞쪽에 문자 상수가 존재하면 인덱스 레인지 스캔을 이용할 수 있지만, "%rist"와 같이 와일드카드가 뒤 쪽에 존재한다면 
인덱스의 Left-most 특성으로 인해 레인지 스캔을 사용하지 못하고 인덱스 풀 스캔 방식으로 처리한다.

#### BETWEEN 연산자

⚠️ BETWEEN와 IN의 차이점

![image](https://github.com/user-attachments/assets/a6a0d3ac-fcfd-49df-a3eb-09d0700ea0f1)

둘 다 인덱스 레인지 스캔을 수행하지만, BETWEEN은 선형으로 검색하고, IN은 동등 비교를 하며 수행하기 때문에 d003 중에서 10005번 아래에 있는 값은 10005번 보다 높다는 것을
이미 알고 있다.

그래서 BETWEEN이 너무 많이 조회할 경우, IN으로 최적화 하는 방식을 고려해보자.

#### IN 연산자

앞서 BETWEEN에서 언급한 대로, 범위로 검색하는 것이 아닌 여러 번의 동등 비교로 실행한다.

8.0 버전 부터는 IN 절에 튜플(레코드)를 사용하면 풀 테이블 스캔이 발생하지 않고 인덱스 레인지 스캔으로 실행된다.

⚠️ NOT IN의 경우에는 부정형 비교라서 인덱스 풀 스캔이 발생한다.

### 11.3.3 MySQL 내장 함수

- 내장 함수
- 사용자 정의 함수

💡 함수 이름, 사용법은 표준이 없으므로 DBMS별로 거의 호환되지 않는다.

⚠️ 프로시저, 스토어드 함수와는 다름.

🤔 DBMS가 이해하도록 하는 타입 변환 이외에는 거의 쓰일 일이 없지 않을까 생각한다. 어플리케이션 단에서 전부 처리가 가능하기 때문.

#### NULL값 비교

- `IFNULL()`: IFNULL(NULL, 1)
- `ISNULL()`: ISNULL(0)

#### 현재 시각 조회

- `NOW()`: 항상 같은 값 반환
- `SYSDATE()` 호출될 때 마다 현재 시각 조회

⚠️ SYSDATE()는 사실상 상수가 아니기 때문에 인덱스 스캔할 때도 매번 비교되는 레코드 마다 함수 실행.

> 한 번만 조회하고 계속 사용하는 `NOW()`를 사용하자.

#### 날짜와 시간의 포맷

- `DATE_FORMAT()`: DATE -> 문자열
- `STR_TO_DATE()`: 문자열 -> DATE

지정 문자는 공식 문서 참고

#### 날짜와 시간의 연산

- `DATE_ADD()`
- `DATE_SUB()`

💡두 번째 인자에 더하거나 빼고자 하는 월의 수, 일의 수 등을 `INTERNAL 1 DAY` 등의 형태로 작성해야 함.

단위는 공식 문서 참고

#### 타임스탬프 연산

- `UNIX_TIMESTAMP()`: DATETIME(혹은 그 형식을 지킨 문자) -> TIMESTAMP
- `FROM_UNIXTIME()`: TIMESTAMP -> DATETIME

TIMESTAMP는 프로그래밍 언어에서 사용한 방식과 동일하다. '1970-01-01 00:00:00'부터 경과된 초 수를 반환.

⚠️ 4 Bytes 숫자 타입으로 저장되기 때문에 실제로 '1970-01-01 00:00:00' ~ '2038-01-09 03:14:07'까지의 날짜만 표현 가능하다고 한다.

#### 문자열 처리

- `RPAD()`, `LPAD()`: 문자열 패딩(123 -> 000000123)
- `RTRIM()`, `LTRIM()`, `TRIM()`: 문자열 공백 제거

#### 문자열 결합

- `CONCAT()`

💡 숫자 값을 인자로 전달하면 문자열 타입으로 자동 변환한 후 문자열 연결한다.

#### GROUP BY 문자열 결합

- `GROUP_CONCAT()`

그룹 함수(Aggregate Function) 중 하나.

GROUP BY가 없다면 하나의 결과값만 반환한다.

⚠️ JDBC로 실행될 때는 에러로 취급되어 쿼리가 실패한다. 그래서 결과 버퍼 크기를 초과하지 않도록 하자.

#### 값의 비교와 대체

- `CASE WHEN ... THEN ...(ELSE ...) END`

프로그래밍 언어의 switch문과 완전 동일.

#### 타입의 변환

기본적으로 SQL은 텍스트(문자열) 기반으로 작동한다.

⚠️ `PreparedStatement`는 문자열이 아닌 각 타입별로 동작한다. 자세한 작동 방식은 [프리페어드 스테이트먼트 - wikipedia](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%AC%ED%8E%98%EC%96%B4%EB%93%9C_%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8%EB%A8%BC%ED%8A%B8) 참조

이 때 타입 변환이 필요할 때 사용한다.

- `CAST()`
- `CONVERT()`: CAST기능 + 문자 집합(utf8mb4...)을 변경할 때 사용

#### 이진 값과 16진수 문자열 변환

- `HEX()`
- `UNHEX()`

#### 암호화 및 해시 함수

- `MD5()`: Message Digest(길이를 줄이다)
- `SHA()`
- `SHA2()`

암호화에 대한 설명은 지금의 주제와 벗어나므로 자세한 내용은 검색해보자.

💡 흔히 비밀번호를 BCrypt 방식으로 인코딩한다. 이 또한 해시 함위는 공식 문서 참고

#### 타임스탬프 연산

- `UNIX_TIMESTAMP()`: DATETIME(혹은 그 형식을 지킨 문자) -> TIMESTAMP
- `FROM_UNIXTIME()`: TIMESTAMP -> DATETIME

TIMESTAMP는 프로그래밍 언어에서 사용한 방식과 동일하다. '1970-01-01 00:00:00'부터 경과된 초 수를 반환.

⚠️ 4 Bytes 숫자 타입으로 저장되기 때문에 실제로 '1970-01-01 00:00:00' ~ '2038-01-09 03:14:07'까지의 날짜만 표현 가능하다고 한다.

#### 문자열 처리

- `RPAD()`, `LPAD()`: 문자열 패딩(123 -> 000000123)
- `RTRIM()`, `LTRIM()`, `TRIM()`: 문자열 공백 제거

#### 문자열 결합

- `CONCAT()`

💡 숫자 값을 인자로 전달하면 문자열 타입으로 자동 변환한 후 문자열 연결한다.

#### GROUP BY 문자열 결합

- `GROUP_CONCAT()`

그룹 함수(Aggregate Function) 중 하나.

GROUP BY가 없다면 하나의 결과값만 반환한다.

⚠️ JDBC로 실행될 때는 에러로 취급되어 쿼리가 실패한다. 그래서 결과 버퍼 크기를 초과하지 않도록 하자.

#### 값의 비교와 대체

- `CASE WHEN ... THEN ...(ELSE ...) END`

프로그래밍 언어의 switch문과 완전 동일.

#### 타입의 변환

기본적으로 SQL은 텍스트(문자열) 기반으로 작동한다.

⚠️ `PreparedStatement`는 문자열이 아닌 각 타입별로 동작한다. 자세한 작동 방식은 [프리페어드 스테이트먼트 - wikipedia](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A6%AC%ED%8E%98%EC%96%B4%EB%93%9C_%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8%EB%A8%BC%ED%8A%B8) 참조

이 때 타입 변환이 필요할 때 사용한다.

- `CAST()`
- `CONVERT()`: CAST기능 + 문자 집합(utf8mb4...)을 변경할 때 사용

#### 이진 값과 16진수 문자열 변환

- `HEX()`
- `UNHEX()`

💡 UUID 3, 5 버전에서는 해시 함수를 사용한다. 그래서 메모리 공간을 아끼기 위해 이진으로 변환하여 `BINARY(16)`으로 저장하는 경우가 많은데 이 때 `HEX()`와 `UNHEX()`를 사용하여 이진 데이터로 변환할 수 있다.

하지만 하이픈(-)을 직접 제거해야 하기 때문에, MySQL에선 내장 함수로 `UUID_TO_BIN()`이라는 함수를 제공한다.

#### 암호화 및 해시 함수

- `MD5()`: Message Digest(길이를 줄이다)
- `SHA()`
- `SHA2()`

암호화에 대한 설명은 지금의 주제와 벗어나므로 자세한 내용은 검색해보자.

#### 처리 대기

- `SLEEP()`

프로그래밍 언어, 쉘 스크립트 언어에서 제공하는 'sleep'기능과 동일

- SQL 개발, 디버깅 용도
- 일부러 쿼리 시간으로 오래 유지하는 용도

⚠️ 초 단위로 받으며, 레코드 건 수 만큼 `SLEEP()`이 호출되기 때문에 레코드 row 조회 수 * SLEEP(초) 만큼 걸린다.

#### 벤치마크

- `BENCHMARK()`

지정한 횟수만큼 쿼리 혹은 함수 등 표현식 반복 실행

- 디버깅 용도
- 간단한 함수 성능 테스트 용도

💡 결과 값이 중요하지 않고, 걸린 시간만 보면 된다.

⚠️ 벤치마크는 네트워크, 쿼리 파싱, 최적화 비용이 단 1번만 발생한다. 그래서 두 개의 동일 기능을 **상대적**으로 비교 분석하는 것을 추천한다.

#### IP 주소 변환

- `INET_ATON`
- `INET_NTOA`

#### JSON

- `JSON_PRETTY()`
- `JSON_STORAGE_SIZE()`
- `JSON_EXTRACT()` = `->`, `JSON_UNQUOTE()` = `->>`(extract + unquote)
- `JSON_CONTAINS()`
- `JSON_OBJECT()`
- `JSON_OBJECTAGG()` & `JSON_ARRAYAGG()`
- `JSON_TABLE()`

#### 🤔 JSON 형식을 저장하는 것에 대한 고민

> - 데이터의 규모가 작고 단순한 경우(10000개 이하)라면 JSON 파일로 충분히 사용 가능하다
> - 데이터의 규모가 크거나 빠른 성장이 예상되는 경우엔 MySQL 사용을 권장한다.
> - 데이터 분석 혹은 검색을 사용하는 경우 MySQL 사용 필수.
> 
> 성능 면에서는 JSON보다 MySQL이 INSERT를 제외하고 더 빠르다.
> 
> JSON은 데이터 유형이 상당히 친숙하여 이해하기 수월하다.
> 
> -MySQL 성능 최적화

> MySQL 8.0 버전으로 업그레이드 되면서 JSON 관련 기능들이 상당히 많이 개선되고 보안되었다.
>
> -Real MySQL 8.0

아무래도 컬럼에 있지 않다 보니, 복잡한 쿼리나 검색 알고리즘 사용은 불가능하다고 하니 아직은 다들 사용하는 것을 꺼려하는 것 같다. 차라리 NoSQL을 사용하는 것이 더 좋아 보인다.
