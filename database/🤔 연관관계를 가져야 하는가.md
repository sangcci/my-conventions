### 생명 주기

양방향 Entity, 연관관계의 떡칠 코드 + DB Entity를 domain으로 사용하는 조합을 보면,
서비스 로직을 작성할 때 
- Entity를 불러오고 반환하는 과정이 정말 많다.
- JPA를 사용했을 때의 쿼리 최적화 문제도 발생한다.

Entity를 불러오고 반환하는 과정이 서비스 로직에 많아질수록, 코드를 이해하기 힘들어지고 정작 중요한 비즈니스 로직을 이해하지 못하는 경우가 많다.

JPA의 N+1 문제는 덤으로 발생하고, 순환 참조 문제로 인해 StackOverFlow까지 발생할 수 있는 최악의 조건이다.

> 객체의 생명주기가 '완전히' 같다면 연관관계 도입을 '고민'한다.
제민님의 영상에서 언급한 내용에 의하면, 왠만하면 연관관계를 걸지 않는다고 하는데 위 경우라면 도입을 고민한다고 한다.

### 무결성

제민님의 영상에서 언급한 내용에 의하면,
어떤 데이터냐에 따라 다르게 설정하며 만일 데이터가 무결성을 매우 중요시하게 생각한다면 연관관계를 거는것이 중요하다고 한다.

하지만 그렇게까지 무결성을 지키지 않아도(물론 지킬려고 최선의 노력은 가하지만) 서비스 운영 상에 큰 문제가 발생하지 않는다면, 운영 편의성을 위해 걸지 않는다.

무결성을 지키기 위한 다양한 방법들이 있다.
- delete 대신 soft delete 방식 도입
- 무결성 요구사항 철저히 분석하여 어플리케이션 단에서 구현

### 쓸데 없는 데이터

해당 도메인에 필요한 데이터만 가져오면 되는데, 다른 entity 자체를 연관관계로 가져버리면 쓸데 없는 데이터까지 딸려 오는 경우가 있다.

그리고 대부분의 "구별"을 위한 검증은 `id` 즉 식별자만으로도 해결되는 경우가 많다.

그렇기 때문에 쓸데 없이 다른 Entity 데이터를 가져오는 `JOIN` 쿼리가 발생하는 경우가 잦으며, 이는 성능 저하로 이어진다(`LAZY` 로딩 전략이 있긴 하다). 

### 테스트 용이성 저하

`id`에 관한 테스트 문제이다.

보통 `AUTO_INCREMENT` 전략일 경우 `id`값이 잘못 들어가는 것을 방지하기 위해 생성자에 `id`를 막아놓는 경우가 있다.

이 때문에 테스트 시 다음과 같은 `Spy`객체를 만들어야 한다.

```java
user = Mockito.spy(createUser());
lenient().when(user.getId()).thenReturn(1L);
```

이는 테스트에서 영향을 미치는데,

id 값만을 가져오면 되는데 반해 `User` 전체를 가져와야 비교할 수 있기 때문에 service 테스트 시 Mocking에 대한 반환 값으로 `User` 전체를 해야 한다.

하지만 생성자에 `id`값을 막아놓았기 때문에 또 `spy`객체를 만들어 `getId()`를 1L로 반환하도록 만들어야 한다.

악순환의 반복이다.

# 연관관계를 끊고 나서

### 객체지향에 가까운 domain 설계 유도

### 테스트 수월



---

[ID로 다른 애그리게잇을 참조하라 - Yoo Young-mo](https://medium.com/@SlackBeck/id%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9E%87%EC%9D%84-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC-4d64f1591e60)

[DB 외래키에 대해 / JPA 인덱스 명시 + 양방향 연관관계 - 제미니의 개발실무](https://www.youtube.com/watch?v=6q0-IT5J0nI)

[JPA Entity 연관관계 어떻게 걸까요? + 엔티티 연관관계 PTSD - 제미니의 개발실무](https://www.youtube.com/watch?v=vgNHW_nb2mg)
