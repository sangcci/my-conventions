# 외부 환경 설정

- 외부 모듈의 설정에 필요한 변수
- 어플리케이션 코드에 노출되기에 부담스러운 변수

# flow

1. 외부 속성 값 인식
   
   어플리케이션 실행 시 외부 속성 값을 인식하여 `Environment`에 저장한다.
2. 어플리케이션에 주입

   해당 값들을 꺼내서 어플리케이션에 주입한다.

---

# 외부 속성 값 인식 - `@PropertySource`

### PropertySource
> Spring에서 PropertySoruce라는 자료구조를 통해 외부 속성 값을 저장하여 Environment Abstraction 기능을 지원한다.

💡**처음 어플리케이션 실행 시 인식한다!**

`@PropertySource` 어노테이션을 `Config` 클래스에 선언한다면, 
어플리케이션 시작 시 Spring Context가 외부 속성들을 인식하여 `Environment` 객체에 환경 변수로 저장한다.

```java
@Configuration
@ComponentScan{
	basePackages = {"org. ...."}
}
@PropertySource("application.properties") // application.properties 속성을 가져와서 Environment에 저장하도록 한다.
public class AppConfig {
}
```

context를 생성 후, `Environment`에서 `getEnvironment()`를 통해서 propertySource들을 확인하거나 직접 추가할 수 있다!

```java
ConfigurableApplicationContext ctx = new GenericApplicationContext(); // context 생성 시점에 내부에서 `@PropertySource`를 인식하여 외부로부터 설정 값을 가져와 Environment에 저장한다.
MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); 
sources.addFirst(new MyPropertySource()); // 직접 추가할 수도 있음.
```

- `.properties` 인식
- PropertySources 추가

<details>
  <summary><h3>spring lagacy에서 yaml 인식하기</h3></summary>
  
기본적으로 `@PropertySource()`는 `yml`파일 형식을 지원하지 않는다. 
그래서 **yml 형식으로 바꾸는 `PropertySourceFactory`를 구현**해야 한다.

Spring에서 `YamlPropertiesFactoryBean()`을 지원한다. 

```java
public class YamlPropertiesFactory implements PropertySourceFactory {
	@Override
	public PropertySource<?> createPropertySource(String s, EncodedResource encodedResoure) throws IOException {
		var yamlPropertiesFactoryBean = new YamlPropertiesFactoryBean();
yamlPropertiesFactoryBean.setResources(encodedResource.getResource());

	var properties = yamlPropertiesFactoryBean.getObject();
	return new PropertiesPropertySource(encodeResource.getResource(), getFilename(), properties);
	}
}

@Configuration
@ComponentScan{
	basePackages = {"org. ...."}
}
@PropertySource(value = "application.yml", factory = YamlPropertiesFactory.class)
public class AppConfig {
}
```

다음과 같이 일일이 yml로 변환해주는 Factory를 만들고, `@PropertySource`에 등록해야 한다.


[Environment Abstraction - spring framework reference](https://docs.spring.io/spring-framework/reference/core/beans/environment.html#beans-property-source-abstraction)

[YAML로 프로퍼티 작성 - yanju](https://velog.io/@leehanju408/YAML%EB%A1%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9E%91%EC%84%B1-c3pz7yvb)
</details>
 



---

# 속성 값 주입

### `@Value`

> `@Value` 어노테이션을 사용하면 외부 properties로부터 값을 필드에 주입할 수 있다.

`@Value("a")`를 하면 필드에 `"a"`가 주입되는 기능인데, 이를 `${..}`로 표현하면 외부 properties로부터 가져올 수 있게 된다.

그 후에 `${..}`표현을 통해 주입해줄수 있다.

[Using `@Value` - spring framework reference](https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/value-annotations.html)

### `@Value` 어노테이션의 주입 시점

> Note that actual processing of the @Value annotation is performed by a **BeanPostProcessor** which in turn means that you cannot use @Value within **BeanPostProcessor** or **BeanFactoryPostProcessor** types. Please consult the javadoc for the **AutowiredAnnotationBeanPostProcessor** class (which, by default, checks for the presence of this annotation).

`Bean`의 생성 시점이 아닌, `BeanPostProcessor`에서 초기화 된다. 그래서 `Bean`이 생성된 직후에 초기화 되므로 서로 생성 시점이 다르다.

```java
// Bean 생성 시점
@Value(${image.path})
String path = null;
final String imagePath = FOLDER_PATH + path(지금 null임);

// Bean 생성 이후 PostProcessor 동작
@Value(${image.path})
String path = "C:/...";
final String imagePath = FOLDER_PATH + path(null 그대로);
```

메서드로 참조하는 것은 괜찮지만, 위처럼 필드에 생성자 시점에 초기화되는 변수일 경우 조심해서 사용하자.

### `@ConfigurationProperties`

> `@Value`와 다르게, 이름으로 구분하여 클래스 기준 모든 필드에 바인딩할 수 있게 하는 기능이다.

🤔 실제로 잘 사용하진 않는다..

> Not registered via @EnableConfigurationProperties, marked as Spring component, or scanned via @ConfigurationPropertiesScan 

Spring framework는 **Config 객체**에 `@EnableConfigurationProperties`를 선언해야 한다. 아니면 위와 같은 에러 메세지를 만날 수 있다.

- `@EnableConfigurationProperties`: `@Component`로 되어 있는 객체 중에서 `@ConfigurationProperties`가 적힌 곳의 필드값에 주입
- `@ConfigurationPropertiesScan`: 주입하고 싶은 클래스에 달아놓으면 Spring Boot의 Scan 대상에 추가되어 주입해줌.

```java
@Getter
@RequiredArgsConstructor
@ConfigurationProperties(prefix = "spring.datasource")
public class DataSourceProperties {

	private final String driverClassName;
	private final String url;
	private final String username;
	private final String password;
}
```

> property 양이 많은 경우 `@ConfigurationProperties`를 활용하고, 양이 적은 경우 `@Value`로도 충분하다.

```java
@Repository  
@Profile("jdbc")  
@RequiredArgsConstructor  
public class VoucherJdbcRepository implements VoucherRepository {    
  
    private final DataSourceProperties dataSourceProperties;
```
그리고 이렇게 Bean으로 주입을 받으면 필드 값에 주입되는 모습을 확인할 수 있다.

![image](https://github.com/user-attachments/assets/f65241f6-a65a-4aa3-bbdc-f595d53f4df4)


### **프로파일링**

> 속성 값 주입의 분류

특정 데이터베이스를 staging 환경에서만 사용하고 싶을 수 있다. 혹은 local 환경, dev 환경에서만 사용하고 싶을 수 있다.

Spring에서는 이런 특정 상황에 맞는 설정 파일을 그룹화 시킬 수 있는 `Profile`이라는 기능을 제공한다.

```java
var context = new AnnotationConfigApplicationContext(AppConfig.class);
var environment = applicationContext.getEnvironment();
environment.setActiveProfiles("dev");
context.refresh();
```

그래서 `@Qualifier`대신 `@Profile`을 통해서 컴포넌트 스캔 시 직접 프로파일을 활성화 시켜서 가져올 수 있다.

- `@Component`
- Config에서 Bean 메서드
에서 추가할 수 있다.

`@Qualifier`에 대한 부분은 [[📓 spring Autowired]]부분을 참고하자.

---
# In Spring Boot

### yaml 인식 가능

Spring Boot는 아예 yml을 지원하도록 변경되었다.

### 외부 설정 자동 주입

> Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that will get properties from `application.properties` and `application.yml` files.|

spring boot는 `PropertySourcesPlaceholderConfigurer`로 인해 `application`이란 이름의 properties, yml 파일에 있는 설정들을 인식해서 PropertySource객체로 추가해준다.

외부 설정의 우선 순위를 공식 문서에서 확인할 수 있다. 자세한 사항은 [[📓 springboot가 제공하는 기능]]을 참고하자.

**그래서 이런 경우 '인식(`@PropertySource`)'의 과정을 생략하고, 바로 '주입(`@Value` 등..)'하면 된다.**

### yaml에서의 프로파일링

> spring boot 에서는 어플리케이션 코드 외에도 yml에서도 프로파일링을 이용할 수 있다.

```yaml
spring:
  config:
    activate:
      on-profile: local

...

---

spring:
  config:
    activate:
      on-profile: dev

...
```

```java
var springApplication = new SpringApplication(~~Application.class);
environment.setActiveProfiles("dev");
var applicationContext = springApplication.run(args);
```

### IDE 환경변수 등록

실행할 때 IDE에 설정하면, `args`로 직접 전달해주는 기능

IDE에서도 실행하는 방식이 일반 Java Application을 실행하는 것과 조금 다르다.

`~~Application`을 실행하는 설정을 들어가면, 기본 args 설정 외에도 environment 설정, 이외에도 다양한 spring boot 설정을 할 수 있도록 지원한다.

```
// program arguments(String[] args)
--spring.profile.active=dev
```

이렇게 VM 환경 변수에 넣어도 된다.

[[Spring Boot appliation.yml 설정 모음]]을 참고하자.

---

[[Spring] @Value와 @ConfigurationProperties의 사용법 및 차이](https://mangkyu.tistory.com/207)

[Externalized Configuration - spring docs](https://docs.spring.io/spring-boot/reference/features/external-config.html)
